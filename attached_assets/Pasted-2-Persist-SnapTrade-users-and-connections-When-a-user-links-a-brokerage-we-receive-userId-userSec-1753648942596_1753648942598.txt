2. Persist SnapTrade users and connections
When a user links a brokerage, we receive userId, userSecret and a connection ID via the existing “Connect Brokerage” flow. Store this mapping in our database keyed by the Flint user.

For each Flint user, maintain an array of connected brokerage connection IDs.

3. Display brokerage accounts
After a user completes the connection flow, call SnapTrade’s List account details or List balances endpoint using their userId/userSecret and the connection ID to pull metadata, balances and positions.

Render the following on the dashboard:

Brokerage name, account type (e.g., individual, Roth IRA) and total market value.

A list of positions (symbol, quantity, current market value).

A list of cash balances (currency, amount, buying power).

Add a refresh button that triggers SnapTrade’s manual refresh endpoint or re-fetches data.

4. Implement trading workflow
Symbol search: Provide a search box where users can enter a stock/ETF ticker or crypto pair.

When a ticker is entered:

Call SnapTrade’s Search account symbols endpoint to fetch the universal_symbol_id.

Display the symbol description and ask the user to enter quantity and order type (market or limit, buy or sell).

Order preview (recommended):

Call Check equity order impact with universal_symbol_id, quantity, side and order type. Show the estimated cost/fee, verifying the user has sufficient buying power.

Place order:

Once the user confirms, call Place checked equity order with the returned trade_id. For simple trades, you can call Place equity order directly.

On success, show a confirmation with the order status.

Poll List account orders to update the order’s status or subscribe to webhooks if possible.

Crypto trading: Add a toggle for crypto. When selected:

Call Get crypto pairs to display available trading pairs.

After the user picks a pair and enters quantity, call Get crypto pair quote to show the rate.

Place the order using Place crypto order with type="CRYPTOCURRENCY_PAIR".

Enforce rate-limiting by ensuring you never send more than one order per second per account.

5. Integrate Teller for bank accounts (optional but recommended)
Add a “Connect Bank Account” button that launches Teller Connect:

Include verify, balance and transactions in the products array.

Use onSuccess to capture the accessToken and store it in the user’s record.

On the dashboard, display the user’s linked bank accounts:

List account name, type (checking, savings, etc.), current balance, last four digits.

Show recent transactions (date, description, amount, category) by calling GET /accounts/:id/transactions.

Provide a link or modal to view account and routing numbers (when available via verify.instant).

(Optional) Implement payments using Teller:

Let users add a Zelle payee by calling POST /accounts/:id/payees with payee details. If the response includes a connect_token, relaunch Teller Connect to complete MFA.

Allow users to initiate a Zelle payment via POST /accounts/:id/payments. Handle connect_token similarly.

Display outgoing payment history by calling GET /accounts/:id/payments.

6. UX and error handling
Provide clear loading states and error messages for all API calls.

If SnapTrade returns an error about a disabled connection, display instructions to re-connect.

If Teller returns a connect_token due to MFA, automatically reopen Teller Connect with the token.

Always display confirmation dialogs before placing trades or sending payments.

7. Added value features
Performance charts: Use positions and transaction data to show each holding’s performance over time.

Portfolio allocation: Generate a pie chart showing asset allocation (stocks vs. crypto vs. cash).

Investment history: Create a timeline of user buys/sells, dividends and deposits/withdrawals.

Account alerts: Subscribe to SnapTrade/Teller webhooks to notify users when their balance drops below a threshold or when a trade executes.

