Goal: Make the Connect button work without any auth context, persist a userSecret, and have /api/holdings succeed. Also add debug routes.

0) Confirm env loads at boot
At the very top of your server entry file (index.ts / server.ts / app.js):

ts
Copy
Edit
import 'dotenv/config';
Restart and ensure you see a boot log like:

csharp
Copy
Edit
[SnapTrade] SDK init { env: 'sandbox', clientIdTail: '......', consumerKeyLen: N }
1) FRONTEND — remove all user references, always send an email
Create/Update: client/src/lib/userEmail.ts

ts
Copy
Edit
export function getOrPromptUserEmail(): string {
  // 1) try from localStorage
  try {
    const saved = localStorage.getItem('userEmail');
    if (saved && saved.trim()) return saved.trim().toLowerCase();
  } catch {}
  // 2) prompt once (MVP)
  // eslint-disable-next-line no-alert
  const entered = (globalThis.prompt?.('Enter your email to connect your brokerage:') || '').trim().toLowerCase();
  if (!entered) throw new Error('No email provided');
  try { localStorage.setItem('userEmail', entered); } catch {}
  return entered;
}

export function getUserEmailOptional(): string | null {
  try {
    const saved = localStorage.getItem('userEmail');
    return saved ? saved.trim().toLowerCase() : null;
  } catch { return null; }
}
Edit: client/src/components/simple-connect-buttons.tsx
(Replace your mutation with this; no user variable anywhere.)

tsx
Copy
Edit
import React from "react";
import { useMutation } from "@tanstack/react-query";
import { apiRequest } from "../lib/queryClient";
import { getOrPromptUserEmail } from "../lib/userEmail";

export function SnapTradeConnectButton() {
  const connectMutation = useMutation({
    mutationFn: async () => {
      const userEmail = getOrPromptUserEmail();

      const resp = await apiRequest("/api/snaptrade/register", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ userEmail }),
      });
      const data = await resp.json();
      if (!resp.ok) throw new Error(data?.message || "Failed to start SnapTrade Connect");

      const url: string | undefined =
        data?.connect?.redirectURI || data?.connect?.loginRedirectURI || data?.connect?.url;
      if (!url) throw new Error("No SnapTrade Connect URL returned");
      window.location.href = url;
      return true;
    },
  });

  return (
    <button
      onClick={() => connectMutation.mutate()}
      disabled={connectMutation.isLoading}
      className="btn btn-primary"
    >
      {connectMutation.isLoading ? "Connecting..." : "Connect Brokerage"}
    </button>
  );
}
Edit your holdings fetch (e.g., client/src/components/real-time-holdings.tsx or holdings-breakdown.tsx):

tsx
Copy
Edit
import { getUserEmailOptional } from "../lib/userEmail";

async function fetchHoldings() {
  const userEmail = getUserEmailOptional();
  const resp = await fetch("/api/holdings", {
    headers: userEmail ? { "x-user-email": userEmail } : {},
  });
  if (!resp.ok) {
    const msg = await resp.text().catch(() => "");
    throw new Error(msg || "Failed to load holdings");
  }
  return resp.json();
}
2) BACKEND — make sure userSecret is persisted and loaded
If not added yet: file-based store (works immediately on Replit)
src/store/snapUserStore.ts

ts
Copy
Edit
import fs from 'fs';
import path from 'path';

const DATA_DIR = path.join(process.cwd(), 'data');
const FILE = path.join(DATA_DIR, 'snaptrade-users.json');

type Rec = { userId: string; snaptrade_user_secret: string };
type DB = Record<string, Rec>;

function ensureFile() {
  if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR, { recursive: true });
  if (!fs.existsSync(FILE)) fs.writeFileSync(FILE, JSON.stringify({}), 'utf8');
}
function readDB(): DB {
  ensureFile();
  try { return JSON.parse(fs.readFileSync(FILE, 'utf8')) as DB; } catch { return {}; }
}
function writeDB(db: DB) { fs.writeFileSync(FILE, JSON.stringify(db, null, 2), 'utf8'); }

export async function getSnapUserByEmail(userId: string): Promise<Rec | null> {
  const db = readDB();
  return db[userId.toLowerCase()] || null;
}
export async function upsertSnapUserSecret(userId: string, secret: string): Promise<void> {
  const db = readDB();
  db[userId.toLowerCase()] = { userId: userId.toLowerCase(), snaptrade_user_secret: secret };
  writeDB(db);
}
Secret generator src/lib/crypto.ts

ts
Copy
Edit
import { randomBytes } from 'crypto';
export const generateUserSecret = () => randomBytes(32).toString('hex');
SnapTrade config src/lib/snaptrade.ts (ensure it logs at boot)

ts
Copy
Edit
import * as Snaptrade from 'snaptrade-typescript-sdk';
const env = process.env.SNAPTRADE_ENV || 'sandbox';
const clientId = process.env.SNAPTRADE_CLIENT_ID;
const consumerKey = process.env.SNAPTRADE_CONSUMER_KEY;

console.log('[SnapTrade] SDK init', {
  env,
  clientIdTail: clientId?.slice(-6),
  consumerKeyLen: consumerKey?.length,
});

export const snaptradeConfig = new Snaptrade.Configuration({
  consumerKey: consumerKey!,
  clientId: clientId!,
  environment: env as any,
});
export const authApi = new Snaptrade.AuthenticationApi(snaptradeConfig);
export const accountsApi = new Snaptrade.AccountsApi(snaptradeConfig);
export const portfoliosApi = new Snaptrade.PortfolioApi(snaptradeConfig);
export const ordersApi = new Snaptrade.TradeApi(snaptradeConfig);
Register route src/routes/snaptrade.ts

ts
Copy
Edit
import { Router } from 'express';
import { authApi } from '../lib/snaptrade';
import { generateUserSecret } from '../lib/crypto';
import { getSnapUserByEmail, upsertSnapUserSecret } from '../store/snapUserStore';

const r = Router();

r.post('/register', async (req, res) => {
  try {
    const userId = (req.body?.userEmail || '').toString().trim().toLowerCase();
    if (!userId) return res.status(400).json({ message: 'userEmail required' });

    let rec = await getSnapUserByEmail(userId);
    let userSecret = rec?.snaptrade_user_secret;
    if (!userSecret) {
      userSecret = generateUserSecret();
      await upsertSnapUserSecret(userId, userSecret);
      console.log('[SnapTrade] Generated userSecret len:', userSecret.length, 'for', userId);
    } else {
      console.log('[SnapTrade] Using existing userSecret len:', userSecret.length, 'for', userId);
    }

    await authApi.registerUser({ userId, userSecret }); // idempotent OK
    const connect = await authApi.createSnapTradeLogin({
      userId,
      userSecret,
      brokerRedirectUri: process.env.SNAPTRADE_REDIRECT_URI!,
    });

    return res.json({ connect });
  } catch (err: any) {
    console.error('SnapTrade Registration Error:', err?.responseBody || err?.message || err);
    return res.status(500).json({ message: err?.message || 'SnapTrade register failed' });
  }
});

export default r;
Holdings route src/routes/holdings.ts

ts
Copy
Edit
import { Router } from 'express';
import { accountsApi, portfoliosApi } from '../lib/snaptrade';
import { getSnapUserByEmail } from '../store/snapUserStore';

const r = Router();
function pickEmail(req: any): string | null {
  const e1 = req.user?.email, e2 = req.headers['x-user-email'], e3 = req.query.userEmail;
  const email = (e1 || e2 || e3 || '').toString().trim().toLowerCase();
  return email || null;
}

r.get('/', async (req, res) => {
  try {
    const userId = pickEmail(req);
    if (!userId) return res.status(401).send('No user');

    const rec = await getSnapUserByEmail(userId);
    const userSecret = rec?.snaptrade_user_secret;
    if (!userSecret) return res.status(400).send('SnapTrade not registered for user');

    console.log('[SnapTrade] Fetching accounts with userSecret len:', userSecret.length, 'for', userId);
    const accounts = await accountsApi.listAccounts({ userId, userSecret });
    const positions = await Promise.all(
      accounts.map(a => portfoliosApi.getPositions({ userId, userSecret, accountId: a.id! }))
    );
    res.json({ accounts, positions });
  } catch (err: any) {
    console.error('Error fetching holdings:', err?.responseBody || err?.message || err);
    res.status(500).json({ message: 'Failed to fetch holdings' });
  }
});

export default r;
3) DEBUG endpoints (so we can prove what’s stored)
Add to your Express app (or a src/routes/debug.ts file and mount it):

ts
Copy
Edit
app.get('/api/debug/snaptrade/user', async (req, res) => {
  const email = (req.query.email || '').toString().trim().toLowerCase();
  if (!email) return res.status(400).json({ message: 'email required' });
  const rec = await getSnapUserByEmail(email);
  res.json({
    exists: !!rec,
    userId: rec?.userId,
    userSecretLen: rec?.snaptrade_user_secret?.length || 0,
  });
});

app.get('/api/snaptrade/health', async (_req, res) => {
  try {
    // harmless idempotent call to test signatures/keys
    await authApi.registerUser({
      userId: 'healthcheck@flint-investing.com',
      userSecret: 'healthcheck-secret-1234567890',
    });
    res.json({ ok: true });
  } catch (e: any) {
    res.status(500).json({ ok: false, error: e?.responseBody || e?.message });
  }
});
4) Reinstall SDK cleanly (once)
bash
Copy
Edit
npm i snaptrade-typescript-sdk@latest
rm -rf node_modules package-lock.json
npm i
5) Test sequence (exact)
Reload app (dev console should show no user is not defined when you click Connect).

Click Connect Brokerage → enter your email if prompted → should receive Connect URL redirect.

After returning, visit:

GET /api/debug/snaptrade/user?email=scapota@flint-investing.com → expect { exists: true, userSecretLen: 64, ... }

GET /api/snaptrade/health → expect { ok: true } (if 401/1076, fix keys/env/redirect)

Trigger holdings (dashboard auto call or manual). Backend log should show:

csharp
Copy
Edit
[SnapTrade] Fetching accounts with userSecret len: 64 for scapota@flint-investing.com
Response: 200 with accounts/positions.