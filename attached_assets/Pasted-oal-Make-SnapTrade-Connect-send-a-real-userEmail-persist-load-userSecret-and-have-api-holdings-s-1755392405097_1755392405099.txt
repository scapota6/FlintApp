oal: Make SnapTrade Connect send a real userEmail, persist/load userSecret, and have /api/holdings succeed.

1) Patch the frontend connect flow to pass userEmail
Edit: client/src/components/simple-connect-buttons.tsx
Replace your current mutation code with this robust version that always resolves a user email (from auth, prop, or localStorage). If none available, it prompts the user once.

tsx
Copy
Edit
// client/src/components/simple-connect-buttons.tsx
import React from "react";
import { useMutation } from "@tanstack/react-query";
import { apiRequest } from "../lib/queryClient";

// OPTIONAL: if you have an auth hook, import it; otherwise this stays unused.
// import { useAuth0 } from "@auth0/auth0-react"; // example

function resolveUserEmail(): string | null {
  // 1) Try known auth providers (uncomment if you have them)
  // const { user } = useAuth0();
  // if (user?.email) return user.email.toLowerCase();

  // 2) Try localStorage
  const ls = (globalThis?.localStorage?.getItem("userEmail") || "").trim().toLowerCase();
  if (ls) return ls;

  // 3) Fallback: prompt ONCE (store so we never prompt again)
  // In production, replace this with your real auth flow.
  // eslint-disable-next-line no-alert
  const entered = (globalThis?.prompt?.("Enter your email to connect your brokerage:") || "")
    .trim()
    .toLowerCase();
  if (entered) {
    try { globalThis?.localStorage?.setItem("userEmail", entered); } catch {}
    return entered;
  }
  return null;
}

export function SnapTradeConnectButton() {
  const connectMutation = useMutation({
    mutationFn: async () => {
      const userEmail = resolveUserEmail();
      if (!userEmail) throw new Error("No user email available for SnapTrade Connect.");

      // 1) ask backend to (idempotently) register and return connect url
      const resp = await apiRequest("/api/snaptrade/register", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ userEmail }),
      });

      const data = await resp.json();
      if (!resp.ok) {
        throw new Error(data?.message || "Failed to create SnapTrade connect session");
      }
      const url: string | undefined = data?.connect?.redirectURI || data?.connect?.loginRedirectURI || data?.connect?.url;
      if (!url) throw new Error("No SnapTrade connect URL returned from backend.");

      // 2) redirect user into SnapTrade Connect
      window.location.href = url;
      return true;
    },
  });

  return (
    <button
      onClick={() => connectMutation.mutate()}
      disabled={connectMutation.isLoading}
      className="btn btn-primary"
    >
      {connectMutation.isLoading ? "Connecting..." : "Connect Brokerage"}
    </button>
  );
}
This removes user is not defined by never referencing an undefined var and guarantees we send { userEmail } to the backend.

2) Ensure holdings fetch sends/has the same email (until auth middleware is wired)
Edit: client/src/components/holdings-breakdown.tsx (or wherever you call /api/holdings)
Add the same resolver and pass it as a header so backend can read it:

tsx
Copy
Edit
async function fetchHoldings() {
  const userEmail =
    (globalThis?.localStorage?.getItem("userEmail") || "").trim().toLowerCase();
  const resp = await fetch("/api/holdings", {
    headers: userEmail ? { "x-user-email": userEmail } : {},
  });
  if (!resp.ok) throw new Error("Failed to load holdings");
  return resp.json();
}
Make sure your React Query queryFn uses fetchHoldings().

3) Backend: read the email from header/query and use stored userSecret
Edit: src/routes/holdings.ts to use the same email source and never call SnapTrade with an empty userSecret:

ts
Copy
Edit
import { Router } from "express";
import { accountsApi, portfoliosApi } from "../lib/snaptrade";
import { getSnapUserByEmail } from "../store/snapUserStore";

const r = Router();

function pickEmail(req: any): string | null {
  // Preferred: req.user.email from your auth middleware
  const e1 = req.user?.email;
  const e2 = req.headers["x-user-email"];
  const e3 = req.query.userEmail;
  const email = (e1 || e2 || e3 || "").toString().trim().toLowerCase();
  return email || null;
}

r.get("/", async (req, res) => {
  try {
    const userId = pickEmail(req);
    if (!userId) return res.status(401).json({ message: "No user" });

    const rec = await getSnapUserByEmail(userId);
    const userSecret = rec?.snaptrade_user_secret;
    if (!userSecret) {
      console.warn("[SnapTrade] No stored userSecret for", userId);
      return res.status(400).json({ message: "SnapTrade not registered for user" });
    }

    console.log("[SnapTrade] Fetching accounts with userSecret len:", userSecret.length, "for", userId);
    const accounts = await accountsApi.listAccounts({ userId, userSecret });

    const positions = await Promise.all(
      accounts.map((a) =>
        portfoliosApi.getPositions({
          userId,
          userSecret,
          accountId: a.id!,
        })
      )
    );

    return res.json({ accounts, positions });
  } catch (err: any) {
    console.error("Error fetching holdings:", err?.responseBody || err?.message || err);
    return res.status(500).json({ message: "Failed to fetch holdings" });
  }
});

export default r;
4) Backend: registration must persist a secret and return Connect URL
Edit: src/routes/snaptrade.ts (idempotent register)

ts
Copy
Edit
import { Router } from "express";
import { authApi } from "../lib/snaptrade";
import { generateUserSecret } from "../lib/crypto";
import { getSnapUserByEmail, upsertSnapUserSecret } from "../store/snapUserStore";

const r = Router();

r.post("/register", async (req, res) => {
  try {
    const raw = (req.body?.userEmail || "").toString().trim().toLowerCase();
    if (!raw) return res.status(400).json({ message: "userEmail required" });
    const userId = raw;

    let rec = await getSnapUserByEmail(userId);
    let userSecret = rec?.snaptrade_user_secret;

    if (!userSecret) {
      userSecret = generateUserSecret();
      await upsertSnapUserSecret(userId, userSecret);
      console.log("[SnapTrade] Generated new userSecret len:", userSecret.length, "for", userId);
    } else {
      console.log("[SnapTrade] Using existing userSecret len:", userSecret.length, "for", userId);
    }

    // idempotent – OK if already registered with this app
    await authApi.registerUser({ userId, userSecret });

    const connect = await authApi.createSnapTradeLogin({
      userId,
      userSecret,
      brokerRedirectUri: process.env.SNAPTRADE_REDIRECT_URI!,
    });

    return res.json({ connect });
  } catch (err: any) {
    console.error("SnapTrade Registration Error:", err?.responseBody || err?.message || err);
    return res.status(500).json({ message: err?.message || "SnapTrade register failed" });
  }
});

export default r;
This ensures the secret is never blank and is reused—no more userSecret= in your logs.

5) Double-check server boot + env + SDK
At the very top of your server entry file:

ts
Copy
Edit
import "dotenv/config";
Ensure src/lib/snaptrade.ts logs at boot:

ts
Copy
Edit
console.log("[SnapTrade] SDK init", {
  env: process.env.SNAPTRADE_ENV || "sandbox",
  clientIdTail: process.env.SNAPTRADE_CLIENT_ID?.slice(-6),
  consumerKeyLen: process.env.SNAPTRADE_CONSUMER_KEY?.length,
});
Replit Secrets (no quotes/spaces):

SNAPTRADE_CLIENT_ID

SNAPTRADE_CONSUMER_KEY

SNAPTRADE_ENV = sandbox

SNAPTRADE_REDIRECT_URI = <exactly as in SnapTrade dashboard>

Then reinstall the SDK cleanly:

bash
Copy
Edit
npm i snaptrade-typescript-sdk@latest
rm -rf node_modules package-lock.json
npm i
6) Test sequence
Load the app; confirm boot log prints [SnapTrade] SDK init {...} with non-empty values.

Click Connect Brokerage → you should not see user is not defined.

Complete SnapTrade Connect.

Trigger holdings:

Frontend calls /api/holdings with header x-user-email: scapota@flint-investing.com.

Backend log should show Fetching accounts with userSecret len: 64 for scapota@flint-investing.com.

Response 200 with accounts/positions.