Goal: Ensure a non-empty userSecret is generated, persisted, and loaded for every SnapTrade call so /api/snaptrade/register and /api/holdings stop sending userSecret=.

1) Create a tiny persistent store (file-based) for SnapTrade user secrets
Works immediately; we can swap to your DB later.

Add: src/store/snapUserStore.ts

ts
Copy
Edit
import fs from 'fs';
import path from 'path';

const DATA_DIR = path.join(process.cwd(), 'data');
const FILE = path.join(DATA_DIR, 'snaptrade-users.json');

type Rec = { userId: string; snaptrade_user_secret: string };
type DB = Record<string, Rec>;

function ensureFile() {
  if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR, { recursive: true });
  if (!fs.existsSync(FILE)) fs.writeFileSync(FILE, JSON.stringify({}), 'utf8');
}

function readDB(): DB {
  ensureFile();
  const raw = fs.readFileSync(FILE, 'utf8');
  try { return JSON.parse(raw) as DB; } catch { return {}; }
}

function writeDB(db: DB) {
  fs.writeFileSync(FILE, JSON.stringify(db, null, 2), 'utf8');
}

export async function getSnapUserByEmail(userId: string): Promise<Rec | null> {
  const db = readDB();
  const key = userId.toLowerCase();
  return db[key] || null;
}

export async function upsertSnapUserSecret(userId: string, secret: string): Promise<void> {
  const db = readDB();
  const key = userId.toLowerCase();
  db[key] = { userId: key, snaptrade_user_secret: secret };
  writeDB(db);
}
2) One-liner helper to create secrets
Add: src/lib/crypto.ts

ts
Copy
Edit
import { randomBytes } from 'crypto';
export const generateUserSecret = () => randomBytes(32).toString('hex');
3) Single-source SnapTrade SDK config (make sure env is loaded)
At the very top of your server entry (index.ts / server.ts / app.js), add:

ts
Copy
Edit
import 'dotenv/config';
Edit/Create: src/lib/snaptrade.ts

ts
Copy
Edit
import * as Snaptrade from 'snaptrade-typescript-sdk';

const env = process.env.SNAPTRADE_ENV || 'sandbox';
const clientId = process.env.SNAPTRADE_CLIENT_ID;
const consumerKey = process.env.SNAPTRADE_CONSUMER_KEY;

if (!clientId || !consumerKey) {
  console.error('[SnapTrade] Missing CLIENT_ID or CONSUMER_KEY');
}

console.log('[SnapTrade] SDK init', {
  env,
  clientIdTail: clientId?.slice(-6),
  consumerKeyLen: consumerKey?.length,
  sdkVersion: require('snaptrade-typescript-sdk/package.json').version,
});

export const snaptradeConfig = new Snaptrade.Configuration({
  consumerKey: consumerKey!,
  clientId: clientId!,
  environment: env as any, // 'sandbox' or 'production'
});

export const authApi = new Snaptrade.AuthenticationApi(snaptradeConfig);
export const accountsApi = new Snaptrade.AccountsApi(snaptradeConfig);
export const portfoliosApi = new Snaptrade.PortfolioApi(snaptradeConfig);
export const ordersApi = new Snaptrade.TradeApi(snaptradeConfig);
4) Wire /api/snaptrade/register to persist the secret
Edit: your SnapTrade route (e.g., src/routes/snaptrade.ts)

ts
Copy
Edit
import { Router } from 'express';
import { authApi } from '../lib/snaptrade';
import { generateUserSecret } from '../lib/crypto';
import { getSnapUserByEmail, upsertSnapUserSecret } from '../store/snapUserStore';

const r = Router();

r.post('/register', async (req, res) => {
  try {
    const userId = String(req.body.userEmail || '').toLowerCase();
    if (!userId) return res.status(400).json({ message: 'userEmail required' });

    let rec = await getSnapUserByEmail(userId);
    let userSecret = rec?.snaptrade_user_secret;

    if (!userSecret) {
      userSecret = generateUserSecret();
      await upsertSnapUserSecret(userId, userSecret);
      console.log('[SnapTrade] Generated new userSecret len:', userSecret.length, 'for', userId);
    } else {
      console.log('[SnapTrade] Using existing userSecret len:', userSecret.length, 'for', userId);
    }

    // Idempotent; OK if already exists at SnapTrade
    await authApi.registerUser({ userId, userSecret });

    const connect = await authApi.createSnapTradeLogin({
      userId,
      userSecret,
      brokerRedirectUri: process.env.SNAPTRADE_REDIRECT_URI!,
    });

    return res.json({ connect });
  } catch (err: any) {
    console.error('SnapTrade Registration Error:', err?.responseBody || err?.message || err);
    return res.status(500).json({ message: err?.message || 'SnapTrade register failed' });
  }
});

export default r;
5) Make holdings endpoint load the secret (no more userSecret=)
Edit: src/routes/holdings.ts

ts
Copy
Edit
import { Router } from 'express';
import { accountsApi, portfoliosApi } from '../lib/snaptrade';
import { getSnapUserByEmail } from '../store/snapUserStore';

const r = Router();

function getEmailFromReq(req: any): string | null {
  // prefer authenticated user if you have auth middleware; fallback to query for now
  const email = (req.user?.email || req.query.userEmail || req.headers['x-user-email'] || '').toString().toLowerCase();
  return email || null;
}

r.get('/', async (req, res) => {
  try {
    const userId = getEmailFromReq(req);
    if (!userId) return res.status(401).json({ message: 'No user' });

    const rec = await getSnapUserByEmail(userId);
    const userSecret = rec?.snaptrade_user_secret;
    if (!userSecret) {
      console.warn('[SnapTrade] No stored userSecret for', userId);
      return res.status(400).json({ message: 'SnapTrade not registered for user' });
    }

    console.log('[SnapTrade] Fetching accounts with userSecret len:', userSecret.length, 'for', userId);
    const accounts = await accountsApi.listAccounts({ userId, userSecret });

    const positions = await Promise.all(
      accounts.map(a => portfoliosApi.getPositions({ userId, userSecret, accountId: a.id! }))
    );

    return res.json({ accounts, positions });
  } catch (err: any) {
    console.error('Error fetching holdings:', err?.responseBody || err?.message || err);
    return res.status(500).json({ message: 'Failed to fetch holdings' });
  }
});

export default r;
6) Make your dashboard code use the same store
Search for the log: “SnapTrade credentials not available for user” and replace that branch to read from getSnapUserByEmail(...) (same as above). It must not rely on a different table/setting than the new store.

7) Frontend call must send the email
In the Connect button code (e.g., simple-connect-buttons.tsx), ensure POST /api/snaptrade/register receives the user’s email:

ts
Copy
Edit
await apiRequest('/api/snaptrade/register', {
  method: 'POST',
  body: JSON.stringify({ userEmail: currentUser.email }), // ensure this is non-empty!
});
Also, for /api/holdings, either rely on auth middleware (preferred) or send ?userEmail= during testing.

8) Sanity checks + test sequence
On server boot, confirm this log prints with real values:

[SnapTrade] SDK init { env: 'sandbox', clientIdTail: '......', consumerKeyLen: N, sdkVersion: '...' }

Click Connect:

Expect logs like:

[SnapTrade] Generated new userSecret len: 64 for scapota@flint-investing.com (first time)

Or Using existing userSecret len: 64 ... (subsequent)

After Connect, call /api/holdings:

Expect log: Fetching accounts with userSecret len: 64 for scapota@flint-investing.com

Expect 200 response with accounts/positions.

9) If /api/snaptrade/register still 401 (code 1076)
That’s signature-level (keys/env/redirect mismatch). Do this once:

Re-check Replit Secrets (no quotes/spaces):

SNAPTRADE_CLIENT_ID and SNAPTRADE_CONSUMER_KEY from the same SnapTrade app

SNAPTRADE_ENV = sandbox

SNAPTRADE_REDIRECT_URI must exactly match the app’s redirect in SnapTrade dashboard

Then:

bash
Copy
Edit
npm i snaptrade-typescript-sdk@latest
rm -rf node_modules package-lock.json
npm i
Retry. If still failing, rotate/regenerate the Consumer (Signing) Key in the same app, update the secret, restart, and retest.

Deliverables:

New files: src/store/snapUserStore.ts, src/lib/crypto.ts

Updated: src/lib/snaptrade.ts, src/routes/snaptrade.ts, src/routes/holdings.ts, server entry with dotenv/config

Frontend: ensure register call includes userEmail

Post the new server logs (SDK init + register + holdings) if anything is still off, and I’ll pinpoint the next fix.









Ask ChatGPT
